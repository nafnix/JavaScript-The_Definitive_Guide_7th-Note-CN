## 操作CSS

### CSS类

`Element`对象的`classList`属性可以用来方便地对HTML的`class`属性添加或删除。

假设文档包含`hidden`类：

```js
document.querySelector("#tooltip").classList.remove("hidden");

document.querySelector("#tooltip").classList.add("hidden");
```

### 行内样式

DOM在所有`Element`上都定义了`style`属性，该`style`属性是`CSSStyleDeclaration`对象，是对HTML里作为`style`属性值的CSS样式文本解析后得到的一个表示。

```js
function displayAt(tooltip, x, y){
    tooltip.style.display = "block";
    tooltip.style.position = "absolute";
    tooltip.style.left = `${x}px`;
    tooltip.style.right = `${y}px`;
}
```

CSS属性名里的连字符在对应的`CSSStyleDeclaration`属性名里会被剔除，并将连字符后的字母转为大写，即如CSS的`font-family`在JS中转为`fontFamily`。

CSS中：

```css
display: block;
font-family: sans-serif;
background-color: #ffffff;
```

JS中，假设操作元素`e`：

```js
e.style.display = "block";
e.style.fontFamily = "sans-serif";
e.style.backgroundColor = "#ffffff";
```

将某个CSS属性设置为计算值，也要确保在计算表达式末尾加上单位：

```js
e.style.left = `${x0 + left_border + left_border}px`;
```

`style`属性只表示元素的行内样式。大多元素的多样式都是在样式表中指定。

### 计算样式

元素的计算样式(computed style)：浏览器根据一个元素的行内样式和所有样式表中适用的样式规则导出的一组属性值。

计算样式也用`CSSStyleDeclaration`表示，但计算样式只读。

`window.getComputedStyle(查询元素, CSS伪元素)`：获取一个元素的计算样式，返回值是`CSSStyleDeclaration`对象，该对象包含应用给指定元素(或伪元素)的所有样式。

```js
let title = document.querySelector("#section1title");
let styles = window.getComputedStyle(title);
let beforeStyles = window.getComputedStyle(title, "::before");
```

- 计算样式的属性只读
- 计算样式的属性是绝对值，百分比和点等相对单位都被转为绝对值。任何指定大小的属性都将以像素度量。值为颜色的属性将以`"rgb()"`格式返回。
- 简写属性不会被计算，只有它们代表的基础属性会被计算。如不能查`margin`属性，而要查`marginLeft`、`marginTop`等。
- 计算样式的`cssText`属性是`undefined`。

### 操作样式表

样式表通过`<style>`或`<link rel="stylesheet">`与HTML关联的。可以给它们指定`id`属性，然后用`querySelector()`找到他们。

`<style>`和`<link>`对应的`Element`对象都有`disabled`属性，可以用它禁用整个样式表。

```js
// 该函数实现 light 和 dark 主题切换
function toggleTheme() {
    let lightTheme = document.querySelector("#light-theme");
    let darkTheme = document.querySelector("#dark-theme");
    if (darkTheme.disabled) {		// 当前是浅色主题 切换到深色主题
        lightTheme.disabled = true;
        darkTheme.disabled = false;
    } else {
        lightTheme.disabled = false;
        darkTheme.disabled = true;
    }
}
```

插入新样式表：

```js
function setTheme(name) {
    let link = document.createElement("link");
    link.id = "theme";
    link.rel = "stylesheet";
    link.href = `themes/${name}.css`;
    
    // 通过id="theme"查找当前的<link>元素
    let currentTheme = document.querySelector("#theme");
    if(currentTheme){
        currentTheme.replaceWith(link);
    } else {
        document.head.append(link);
    }
}
```

### CSS动画与事件

```css
.transparent { opacity: 0; }					/* 完全透明 */
.fadeable { transition: opacity .5s ease-in } 	/* 不透明度变化 0.5秒 */
```

HTML：

```html
<div id="subscribe" class="fadeable notification">
    ...
</div>
```

JS：

```js
document.querySelector("#subscribe").classList.add("transparent");
```

该元素为不透明度动画配置。给其添加`"transparent"`类，会触发动画：浏览器半秒内让元素'"淡出"为完全透明。

相反如果移除该类，则元素淡入。

首次触发过渡时，浏览器派发`"transitionrun"`事件。当视觉上发生变化时，派发`"transitionstart"`事件，动画完成时，派发`"transitionend"`事件。这些事件的目标都是发生动画的元素。这些事件传给处理程序的事件对象是个`"Transitionend"`。该对象的`propertyName`属性是发生动画的CSS属性，`"transitionend"`事件对应的事件对象的`elapsedTime`属性是从`"transitionstart"`事件开始经过的秒数。

CSS动画也触发事件，可以供JS代码监听：

- 动画开始时触发`"animationstart"`事件
- 动画完成时触发`"animationend"`事件
- 动画每次重复(不包括最后一次)都会触发`"animationiteration"`事件

事件目标是发生动画的元素，传给处理程序的事件对象是`AnimationEvent`对象。该对象的`animationName`属性是定义动画的`animation-name`属性，`elapsedTime`属性反映了自动画开始以后经过了多少秒。
