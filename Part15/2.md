## 操作CSS

### CSS类

`Element`对象的`classList`属性可以用来方便地对HTML的`class`属性添加或删除。

假设文档包含`hidden`类：

```js
document.querySelector("#tooltip").classList.remove("hidden");

document.querySelector("#tooltip").classList.add("hidden");
```

### 行内样式

DOM在所有`Element`上都定义了`style`属性，该`style`属性是`CSSStyleDeclaration`对象，是对HTML里作为`style`属性值的CSS样式文本解析后得到的一个表示。

```js
function displayAt(tooltip, x, y){
    tooltip.style.display = "block";
    tooltip.style.position = "absolute";
    tooltip.style.left = `${x}px`;
    tooltip.style.right = `${y}px`;
}
```

CSS属性名里的连字符在对应的`CSSStyleDeclaration`属性名里会被剔除，并将连字符后的字母转为大写，即如CSS的`font-family`在JS中转为`fontFamily`。

CSS中：

```css
display: block;
font-family: sans-serif;
background-color: #ffffff;
```

JS中，假设操作元素`e`：

```js
e.style.display = "block";
e.style.fontFamily = "sans-serif";
e.style.backgroundColor = "#ffffff";
```

将某个CSS属性设置为计算值，也要确保在计算表达式末尾加上单位：

```js
e.style.left = `${x0 + left_border + left_border}px`;
```

`style`属性只表示元素的行内样式。大多元素的多样式都是在样式表中指定。

### 计算样式

元素的计算样式(computed style)：浏览器根据一个元素的行内样式和所有样式表中适用的样式规则导出的一组属性值。

计算样式也用`CSSStyleDeclaration`表示，但计算样式只读。

`window.getComputedStyle(查询元素, CSS伪元素)`：获取一个元素的计算样式，返回值是`CSSStyleDeclaration`对象，该对象包含应用给指定元素(或伪元素)的所有样式。

```js
let title = document.querySelector("#section1title");
let styles = window.getComputedStyle(title);
let beforeStyles = window.getComputedStyle(title, "::before");
```

- 计算样式的属性只读
- 计算样式的属性是绝对值，百分比和点等相对单位都被转为绝对值。任何指定大小的属性都将以像素度量。值为颜色的属性将以`"rgb()"`格式返回。
- 简写属性不会被计算，只有它们代表的基础属性会被计算。如不能查`margin`属性，而要查`marginLeft`、`marginTop`等。
- 计算样式的`cssText`属性是`undefined`。

### 操作样式表

样式表通过`<style>`或`<link rel="stylesheet">`与HTML关联的。可以给它们指定`id`属性，然后用`querySelector()`找到他们。

`<style>`和`<link>`对应的`Element`对象都有`disabled`属性，可以用它禁用整个样式表。

```js
// 该函数实现 light 和 dark 主题切换
function toggleTheme() {
    let lightTheme = document.querySelector("#light-theme");
    let darkTheme = document.querySelector("#dark-theme");
    if (darkTheme.disabled) {		// 当前是浅色主题 切换到深色主题
        lightTheme.disabled = true;
        darkTheme.disabled = false;
    } else {
        lightTheme.disabled = false;
        darkTheme.disabled = true;
    }
}
```

插入新样式表：

```js
function setTheme(name) {
    let link = document.createElement("link");
    link.id = "theme";
    link.rel = "stylesheet";
    link.href = `themes/${name}.css`;
    
    // 通过id="theme"查找当前的<link>元素
    let currentTheme = document.querySelector("#theme");
    if(currentTheme){
        currentTheme.replaceWith(link);
    } else {
        document.head.append(link);
    }
}
```

### CSS动画与事件

```css
.transparent { opacity: 0; }					/* 完全透明 */
.fadeable { transition: opacity .5s ease-in } 	/* 不透明度变化 0.5秒 */
```

HTML：

```html
<div id="subscribe" class="fadeable notification">
    ...
</div>
```

JS：

```js
document.querySelector("#subscribe").classList.add("transparent");
```

该元素为不透明度动画配置。给其添加`"transparent"`类，会触发动画：浏览器半秒内让元素'"淡出"为完全透明。

相反如果移除该类，则元素淡入。

首次触发过渡时，浏览器派发`"transitionrun"`事件。当视觉上发生变化时，派发`"transitionstart"`事件，动画完成时，派发`"transitionend"`事件。这些事件的目标都是发生动画的元素。这些事件传给处理程序的事件对象是个`"Transitionend"`。该对象的`propertyName`属性是发生动画的CSS属性，`"transitionend"`事件对应的事件对象的`elapsedTime`属性是从`"transitionstart"`事件开始经过的秒数。

CSS动画也触发事件，可以供JS代码监听：

- 动画开始时触发`"animationstart"`事件
- 动画完成时触发`"animationend"`事件
- 动画每次重复(不包括最后一次)都会触发`"animationiteration"`事件

事件目标是发生动画的元素，传给处理程序的事件对象是`AnimationEvent`对象。该对象的`animationName`属性是定义动画的`animation-name`属性，`elapsedTime`属性反映了自动画开始以后经过了多少秒。

## 文档几何与滚动

有时候必须要知道某个元素精确的几何位置。

### 文档坐标与视口坐标

文档元素的位置以CSS像素度量：元素的x和y坐标可以相对于文档的左上角，也可以相对于显示文档的视口(viewport)的左上角。

### 查询元素的几何大小

`getBoundingClientRect()`：确定元素大小和位置。返回一个对象，对象属性`left`和`top`是元素左上角的x和y坐标，`right`和`bottom`是右下角的坐标。这两对属性值的差就是`width`和`height`。

块级元素在浏览器的布局始终是矩形。

行内元素可能跨行，因而包含多个矩形。如`<em>`和`</em>`标签间的文本显示在两行上，则它的矩形会包含第一行末尾和第二行开头。若在该元素上调用`getBoundingClientRect()`，则边界矩形将包含两行的整个宽度。如果想查询行内元素中的个别矩形，可以调用`getClientRects()`，得到一个只读的类数组对象，元素类似`getBoundingClientRect()`返回的举行对象。

### 确定位于某一点的元素

`Document`对象的`elementFromPoint()`：确定在视口中某个给定位置上的是哪个元素。需要传入x和y的视口坐标。返回位于指定位置的`Element`对象。返回相应位置上最内部(嵌套最深)、最外层(最大的CSS`z-index`属性)的元素。

### 滚动

`Window`的`scrollTo()`接受x和y坐标(文档坐标)。滚动窗口，让指定的点位于视口的左上角。

```js
// 滚动浏览器让文档最底部的页面显示出来

// 取得文档和视口的高度
let documentHeight = document.documentElement.offsetHeight;
let viewportHeight = window.innerHeight;

// 滚动到最后一"页"在视口中可见
window.scrollTo(0, documentHeight - viewportHeight);
```

还有个`scrollBy()`方法与`scrollTo()`类似，但其参数是个相对值，会加在当前滚动位置上：

```js
// 每500毫秒向下滚动50像素 无法停止
setInterval(() => { scrollBy(0, 50)}, 500 );
```

想让`scrollTo()`和`scrollBy()`平滑滚动，需要传入一个对象：

```js
window.scrollTo({
    left: 0,
    top: documentHeight - viewportHeight,
    behavior: "smooth"
});
```

HTML元素上调用`scrollIntoView()`：滚动到某个元素的视口中可见。

- 默认情况下，滚动后的结果会尽量让元素的上边对齐或接近视口上沿。
- 若给该方法传入唯一的参数`false`，则滚动后的结果会尽量让元素的底边对齐视口下沿。
- 传入对象，设置：
  - `behavior: "smooth"`：实现平滑滚动
  - `block`属性：指定元素在垂直方向上如何定位
  - `inline`属性：指定元素在水平方向上如何定位
  - 这两个属性的有效值均包括`start`、`end`、`nearest`、`center`

### 视口大小、内容大小和滚动位置

浏览器窗口的视口大小获得：`window.innerWidth`和`window.innerHeight`

文档的整体大小与`<html>`元素相同：`document.documentElement`。

获得文档宽度和高度：`document.documentElement`的`getBoundingClientRect()`方法，也可以用`document.documentElement`的`offsetWidth`和`offsetHeight`。

文档在视口中的滚动位移可以通过`window.scrollX`和`window.scrollY`获得。这两个属性都是只读，所以不能设置它们的值来滚动文档。

滚动文档应该用`window.scrollTo()`。

每个`Element`对象都定义了下列三组属性：

1. `offset`：只读
   - `offsetWidth`和`offsetHeight`：它们在屏幕上的CSS像素大小。包含元素边框和内边距，但不含外边距。
   - `offsetleft`和`offsetTop`：元素的`x`和`y`坐标。对很多元素来说，这是文档坐标。但对定位元素的后代或一些如表格单元来说，是相对于祖先元素而非文档的坐标。
   - `offsetParent`：保存前述坐标值相对于哪个元素。
2. `cliend`：只读
   - `cliendWidth`和`cliendHeight`：类似`offset`对应的，但不含元素边框，只包含内容区及内边距。
   - `cliendLeft`和`cliendTop`：元素内边距外沿到边框外沿的水平和垂直距离。
3. `scroll`
   1. `scrollWidth`和`scrollHeight`：元素内容区大小加上元素内边距再加溢出内容的大小。内容没溢出时与`client`对应的相等。
   2. `scrollLeft`和`scrollTop`：元素内容在元素视口中的滚动位移。可写属性。

## Web组件

### 使用Web组件

Web组件在JS中定义，要在HTML中使用Web组件，需要包含定义该组件的JS文件。

```html
<script type="module" src="components/search-box.js"></script>
```

Web组件要定义自己的HTML标签名，标签名必须包含一个连字符。使用Web组件，像如下使用在HTML文件中使用标签即可：

```html
<serach-box placeholder="Search..."></serach-box>
```

Web组件不能使用自关闭标签定义，如不能`<search-box />`

Web组件可以有子组件。有的Web组件可选地接收有标识地子组件，这些子组件会出现在命名的"插槽"(slot)中。

```html
<search-box>
	<img src="images/search-icon.png" slot="left" />
	<img src="images/cancel-icon.png" slot="right" />
</search-box>
```

插槽名`left`和`right`由该Web组件定义。

当在Web组件还没定义就遇到其标签时，浏览器会向DOM树添加一个通用的`HTMLElement`，即便它们不知道要对它做什么。之后，当自定义元素有定义之后，该通用元素会被"升级"，从而具备预期地外观和行为。

如果Web组件包含子元素，那么在组件有定义前它们可能会被不适当地显示出来。可以使用下面的CSS将Web组件隐藏到它们有定义为止：

```css
/*
 * 让<search-box>组件在定义前不可见
 * 同时尝试复现其最终布局和大小 以便近旁内容在它有定义时不会移动
 */
search-box:not(:defined) {
    opacity: 0;
    display: inline-block;
    width: 300px;
    height: 50px;
}
```

Web组件实现通常会为它们支持的每个HTML属性都定义一个JS属性。

使用的Web组建的文档应该指出可以在JS中使用什么属性和方法。

DOM API将文档组织成一个Node对象树，其中Node可以是`Document`、`Element`、`Text`或`Comment`节点。但这些节点类型不能用于表示一个文档片段，或者一组没有父节点的同辈节点。

`DocumentFragment`：一种`Node`类型，可以临时充当一组同辈节点的父节点，方便将这些同辈节点作为一个单元使用。

- 创建：`document.createDocumentFragment()`
- 添加内容：`append()`
- 与`Element`的区别：没有父节点。
- 向文档插入`DocumentFragment`节点时，`DocumentFragment`本身不会被插入，实际上插入的是它的子节点。

### HTML模板

HTML的`<template>`标签及其子元素永远不会被浏览器渲染，只能在使用JS的网页中使用。通过它可以对页面中经常使用的组件进行优化。

JS里该标签对应的是`HTMLTemplateElement`对象。该对象有个`content`属性，属性值包含`<template>`所有子节点的`DocumentFragment`。克隆`DocumentFragment`再将克隆的副本插入文档中需要的地方。该片段自身不会被插入，只有其子节点会。

假设文档中有个`<table>`和`<template id="row">`标签，后者作为模板定义了表格中行的结构，可以如下使用模板：

```js
let tableBody = document.querySelector("tbody");
let template = document.querySelector("#row");
let clone = document.template.content.cloneNode(true);		// 深度克隆

// 先用DOM把内容插入克隆的<td>元素
// 然后将克隆且已初始化的表格行插入表格体
tableBody.append(clone);
```

### 自定义元素

可以将一个HTML标签与一个JS类关联起来，之后文档中出现的这个标签就会在DOM树里转为相应类的实例。

创建自定义元素需要用`customElements.define()`方法：

1. 参数一：Web组件的标签名(标签名必须包含一个连字符)
2. 参数二：`HTMLElement`的子类

文档中具有该标签名的任何元素都会被"升级"为该类的一个新实例。若浏览器将来再解析HTML，都会自动为遇到的标签创建一个该类的实例。

传给`customElements.define()`的类应该扩展`HTMLElement`，但不要是更具体的类型。

当自定义元素被插入文档时，会调用`connectedCallback()`方法。很多自定义元素通过该方法执行初始化。

`disconnectedCallback()`会在自定义元素从文档中被移除时调用。

若自定义元素类定义了静态的`observedAttributes`属性，这个属性的值是个存有属性名的数组，然后如果这些属性名有一个在这个自定义元素的实例上被设置或者修改，那么浏览器就会调用`attributeChangedCallback(属性名, 旧值, 新值)`方法。

创建自定义元素示例：

```js
customElements.define("inline-circle", class InlineCircle extends HTMLElement {
    // 浏览器会在一个<inline-circle>元素被插入文档时调用这个方法
    connectedCallback() {
        this.style.display = "inline-block";
        this.style.borderRadius = "50%";
        this.style.border = "solid black 1px";
        this.style.transform = "translate(10%)";
        // 如果没有定义大小 则给予当前字体大小设置一个默认大小
        if (!this.style.width) {
            this.style.width = "0.8em";
            this.style.height = "0.8em";
        }
    }
    
    // 这个静态的observedAttributes用于指定我们想在哪些属性变化时收到通知
    static get observedAttributes() { return ["diameter", "color"]; }
    
    // 该回调会在上面列出的属性变化时被调用
    attributeChangedCallback(name, oldValue, newValue) {
        switch(name) {
            case "diameter":
                // 如果diameter属性改变 更新大小
                this.style.width = newValue;
                this.style.height = newValue;
                break;
            case "color":
                this.style.backgroundColor = newValue;
                break;
        }
    }
    
    // 定义和元素的标签属性对应的JS属性
    // 此处获取和设置方法只是获取和设置底层属性
    // 如果设置了JS的属性 那么修改底层的属性会触发调用attributeChangedCallback() 进而更新元素的样式
    get diameter() { return this.getAttribute("diameter"); }
    set diameter(diameter) { this.setAttribute("diameter", diameter); }
    get color() { return this.getAttribute("color"); }
    set color(color) { this.setAttribute("color", color); }
})
```

### 影子DOM

**影子DOM**(shadow DOM)。影子：作为影子根节点后代的元素"藏在影子里"。该子树不属于常规DOM树，不会出现在它们宿主元素的`children`数组里，且对`querySelector()`等常规DOM遍历方法也不可见。

可以把一个"**影子根节点**"(shadow root)附加给一个自定义元素。这里的自定义元素称为"**影子宿主**"(shadow host)。影子宿主元素与所有HTML元素一致，随时可以作为包含后代元素和文本节点的正常DOM树的根。

影子宿主的常规、普通DOM子树有时又称"阳光DOM"(light DOM)。

#### 影子DOM封装

影子根节点的后代对常规DOM树而言是隐藏且独立的，几乎就像是它们是在一个独立的文档中一样。

1. 在创建影子根节点并将其附加于影子宿主时，可以指定其模式：
   - 开放(open)：影子宿主会有个`shadowRoot`属性，JS可以通过该属性访问影子根节点的元素
   - 关闭(closed)：影子根节点被完全封闭，不可访问
2. 在影子根节点下定义的样式对该子树是私有的，永远不会影响外部的阳光DOM元素。影子DOM的元素会从阳光DOM继承字体大小和背景颜色等，影子DOM的样式可以选择阳光DOM中定义的CSS变量。
3. 影子DOM中发生的某些事件(如"load")会被封闭在影子DOM里。另一些事件，像`focus`、`mouse`和键盘事件向上冒泡、穿透影子DOM。一个发源于影子DOM内的事件跨过了边界开始向阳光DOM传播时，其`target`属性会变成影子宿主元素，就像事件直接起源于该元素一样。

#### 影子DOM插槽和阳光DOM子元素

作为影子宿主的HTML元素有两个后代子树：

1. `children[]`数组，宿主元素常规阳光DOM后代
2. 影子根节点及其后代

它们的工作原理：

- 影子根节点的后代始终显示在影子宿主内
- `<slot>`元素：
  - 若这些后代有个`<slot>`元素，则宿主元素的常规阳光DOM子元素会像它们本来就是该`<slot>`的子元素一样显示，替代该插槽中的任何影子DOM元素。
  - 如果影子DOM不包含`<slot>`，那么宿主的阳光DOM内容永远不会显示。
  - 如果影子DOM有个`<slot>`，但影子宿主没有DOM子元素，那么该插槽的影子DOM内容作为默认内容显示。
- 阳光DOM内容显示在影子DOM插槽里时，称那些元素"已分配"(distributed)：那些元素实际上未变成影子DOM一部分。使用`querySelector()`还是可以找到它们，仍作为宿主元素的子元素或后代出现在阳光DOM里。
- 如果影子DOM定义了多个`<slot>`，且通过`name`属性为他们命名，那么影子宿主的阳光DOM后代可以通过`slot="slotname"`属性指定自己想出现在哪个插槽里。

#### 影子DOM API

将一个阳光DOM元素转为影子宿主，只要调用其`attachShadow()`方法，传入`{mode: "open"}`这个唯一参数即可。该方法返回一个影子根节点对象，同时也将该对象设为该数组的`shadowRoot`属性值。

Web组件如果想知道影子ODM(`slot`)中的阳光DOM内容什么时候变化，可以直接在该`<slot>`元素上注册一个`"slotchanged"`事件。

