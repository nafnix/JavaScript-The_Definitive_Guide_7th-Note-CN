# 第三章 类型、值和变量

## 概述与定义

1. 原始类型(不可修改)
   - 数值
   - 字符串
   - 布尔真值
   - null
   - undefined
   - ES6新增：Symbol(符号)
2. 对象类型：不是原始类型的值都是对象，属性的集合，可修改。

JS与静态语言更大的差别：函数和类不仅时语言的语法，本身就是可以被JS程序操作的值。

内存管理：JS解释器会执行自动垃圾收集。

## 数值

JS用IEEE 754标准定义的64位浮点格式表示数值。

### 整数字面量

- 十六进制：`0x`开头或`0X`开头，后跟十六进制数

ES6之后，支持二进制和八进制：

- 二进制：`0b`开头，例如`0b10101`
- 八进制：`0o`开头，例如`0o377`

### 浮点字面量

在实数后跟字母`e`或`E`，跟一个可选的加号或减号，再跟个整数指数。这种记数法表示的是实数值乘以`10`的指数次幂。

```js
3.14
2345.6789
.33333333333
6.02e2 				// 6.02 * 10²
1.4738223E+2		// 1.4738223 * 10²
```

可以用下划线将数值分隔：

```js
let billion = 1_000_000_000;
let bytes = 0*89_AD_CD_EF;
let bits = 0b0001_1101_0111;
let fraction = 0.123_456_789;
```

### JavaScript中的算术

上溢出时，结果时特殊的无穷值`Infinity`。

负数绝对值超出最大可表示负数的绝对值为`-Infinity`。

`0/0=NaN`

`NaN`与任何值比较都不想等，也不等于自己(`NaN`)。可以用`Number.isNaN(变量)`。

```js
Math.pow(2, 53)				// 2的53次方
Math.round(.6)				// 1.0 舍入到最接近的整数
Math.ceil(.6)				// 1.0 向上舍入到一个整数
Math.floor(.6)				// 0.0 向下舍入到一个整数
Math.abs(-5)				// 5 绝对值
Math.max(x, y, z)			// 返回最大的参数
Math.min(x, y, z)			// 返回最小的参数
Math.random()				// 伪随机数x 0 <= x < 1.0
Math.PI						// 圆周率
Math.E						// 自然对数的底数
Math.sqrt(3)				// 3**0.5 3的平方根
Math.pow(3, 1/3)			// 3**(1/3) 3的立方根
Math.sin(0)					// 三角函数 还有Math.cos和Math.atan等
Math.log(10)				// 10的自然对数
Math.log(100)/Math.LN10		// 以10为底100的对数
Math.log(512)/Math.LN2		// 以2为底512的对数
Math.exp(3)					// Math.E的立方
```

ES6新增：

```js
Math.cbrt(27)				// 3 立方根
Math.hypot(3, 4)			// 5 所有参数平方和的平方根
Math.log10(100)				// 2 以10为底的对数
Math.log2(1024)				// 10 以2为底的对数
Math.log1p(x)				// (1+x)的自然对数 精确到非常小的x
Math.expm1(x)				// Math.exp(x)-1 Math.log1p()的逆运算
Math.sign(x)				// 对<、==、>0的参数返回-1、0、1
Math.imul(2, 3)				// 6 优化的32位整数乘法
Math.clz32(0xf)				// 28 32位整数中前导0的位数
Math.trunc(3.9)				// 3 剪掉分数部分得到的整数
Math.fround(x)				// 舍入到最接近的32位浮点数
Math.sinh(x)				// 双曲线正弘 还有Math.cosh()和Math.tanh()
Math.asinh(x)				// 双曲线反正弘 还有Math.acosh()和Math.atanh()
```

### 二进制浮点数与舍入错误

通过JS操作实数的时候，数值表示通常是实际数值的近似值。

```js
let x = .3 - .2;
let y = .2 - .1;

x === y;		// false
x === .1;		// false
y === .1;		// false
```

可以考虑用等量整数。

### 通过BigInt表示任意精度整数

ES2020为JS定义了一种新的数值类型`BigInt`。

```js
1234n		// 一个不太大的BigInt字面量
0b111111n	// 二进制BigInt
0o7777n		// 八进制BigInt
0x8000000000000000n		// 2n**63n 64位整数
```

可以用`BigInt()`将常规JS数值或字符串转为`BigInt`值：

```js
BigInt(Number.MAX_SAFE_INTEGER)
let string = "123412"
BigInt(string)
```

`BigInt`的算术运算与常规JS数值的运算类似，但除法会丢弃余数并向下(向零)舍入：

```js
3000n / 997n	// 3n 商是3
3000n % 997n	// 9n 余数是9
```

相对来说，比较操作符允许混合操作数类型：

```js
1 < 2n		// true
2 > 1n		// true
0 == 0n		// true
0 === 0n	// false 类型不等
```

`Math`对象不接受`BigInt`操作数。

### 日期和时间

`Date`是对象，但也有数值表示形式，即自1970年1月1日起至今的毫秒数，也叫时间戳：

```js
let timestamp = Date.now();		// 当前时间的时间戳
let now = new Date();			// 当前时间的日期对象
let ms = now.getTime();			// 转换为毫秒时间戳
let iso = now.toISOString();	// 转换为标准格式的字符串
```

## 文本

类型`String`。字符串是16位值的不同修改的有序序列，其中每个值都表示一个Unicode字符。

JS使用Unicode字符集的UTF-16编码，所以JS字符串是无符号16位置的序列。

### 字符串字面量

```js
"string"
'string'
`string`				// 反引号 ES6新增
```

### 字符串字面量中的转义序列

| 序列     | 表示的字符                                                   |
| -------- | ------------------------------------------------------------ |
| `\0`     | NUL字符(\u0000)                                              |
| `\b`     | 退格符(\u0008)                                               |
| `\t`     | 水平制表符(\u0009)                                           |
| `\n`     | 换行符(\u000A)                                               |
| `\v`     | 垂直制表符(\u000B)                                           |
| `\f`     | 换页符(\u000C)                                               |
| `\r`     | 回车符(\u000D)                                               |
| `\"`     | 双引号(\u0022)                                               |
| `\'`     | 撇号或单引号(\u0027)                                         |
| `\\`     | 反斜杠(\u005c)                                               |
| `\xnn`   | 由2位十六进制数字`nn`指定的Unicode字符                       |
| `\unnnn` | 由4位十六进制数字`nnnn`指定的Unicode字符                     |
| `\u{n}`  | 由码点`n`指定的Unicode字符，其中`n`是介于`0`和`10FFFF`之间的1到6位十六进制数字(ES6) |

若字符`\`位于上表之外的字符前，那么该反斜杠会被忽略。

### 使用字符串

使用`+`拼接字符串。

字符串的长度：`s.length`

```js
let s = "Hello, World";

// 取字符串
s.substring(1, 4)			// 2~4个字符
s.slice(1, 4)				// 同上
s.slice(-3)					// 最后3个字符
s.split(", ")				// ["Hello", "World"]

// 搜索字符串
s.indexOf("l")				// 2 第一个字母l的位置
s.indexOf("l", 3)			// 3 位置3后面第一个"l"的位置
s.indexOf("zz")				// -1 s并不包含子串"zz"
s.lastIndexOf("l")			// 10 最后一个字母l的位置

// ES6之后版本的布尔值搜索函数
s.startsWith("Hell")		// true 字符串以Hell开头
s.endWith("!")				// false 字符串以!结尾
s.includes("or")			// true 字符串包含or

// 创建字符串的修改版本
s.replace("llo", "ya")		// "Heya, world"
s.toLowerCase()				// "hello, world"
s.toUpperCase()				// "HELLO, WORLD"
s.normalize()				// Unicode NFC 归一化 ES6新增
s.normalize("NFD")			// NFD归一化 还有NFKC和NFKD

// 访问字符串中的个别字符
s.charAt(0)					// "H" 第一个字符
s.charAt(s.lengh-1)			// 最后一个字符
s.charCodeAt(9)				// 72 指定位置的16位数值
s.codePointAt(0)			// 72 ES6 适用于码点大于16位的情形

// ES2017新增的字符串填充函数
"x".padStart(3)				// "  x" 在左侧添加空格 让字符串长度变为3
"x".padEnd(3)				// 右侧加空格
"x".padStart(3, "*")		// 左边加* 让字符串长度变为3
"x".padEnd(3, "-")			// x-- 让字符串长度变为3

// 删除空格函数 trim()是ES5有的 其它是Es2019新增
" test ".trim()				// test 删除开头和末尾的空格
" test ".trimStart()
" test ".trimEnd()

// 未分类字符串方法
s.concat("!")				// Hello, world! 可以用+操作符代替
"<>".repeat(5)				// <><><><><> 拼接5次 ES6新增
```

如`replace`和`toUpperCase`它们是返回新字符串，而不会修改字符串。

可以用下标访问字符串的指定字符：

```js
let words = "hello";
s[0]			// h
```

### 模板字面量

ES6后，字符串字面量可以用反引号：

```js
let s = `hello, world`;
s[0]			// "h"
```

模板字面量可以包含任意JS表达式。反引号内字符串会把表达式求值：

```js
let name = "Bill";
let greeting  = `Hello ${ name }.`;			// "Hello Bill."
```

`${内容}`：内容会被当作JS表达式解释。

#### 标签化模板字面量

若在模板字面量的开头前有个函数名(标签)，那么模板字面量里的文本和表达式的值会作为参数传给该函数。

该特性可用于先对某些值进行HTML或SQL转义，然后再将它们插入文本。

ES6内置了一个标签函数：`String.raw()`。该函数返回反引号中未经出列文本，即不会处理任何反斜杠转义：

```js
`\n`.length					// 1 其中只有一个换行符
String.raw`\n`.length		// 2
```

反引号字符充当开头和末尾的圆括号。

### 模式匹配

JS定义了正则表达式的数据类型(RegExp)：

```js
/^HTML/;			// 匹配字符串开头的字母HTML
/[1-9][0-9]*/;		// 匹配非0数字 后跟任意数字
/\bjavascript\b/i;	// 匹配javascript这个词 不区分大小写
```

RegExp对象定义了一些方法：

```js
let text = "testing: 1, 2, 3";
let pattern = /\d+/g;				// 匹配一个或多个数字
pattern.test(text)					// true 存在匹配项
text.search(pattern)				// 9 第一个匹配项的位置
text.match(pattern)					// ["1", "2", "3"] 所有匹配项的数组
text.replace(pattern, "#")			// testing: #, #, #
text.split(/\D+/)					// ["", "1", "2", "3"] 基于非数字拆分
```

更多的会在11章说明。

## 布尔值

下面的都是`false`：

- `undefined`
- `null`
- `0`
- `-0`
- `NaN`
- `""`：空字符串

其他的都是`true`

如果需要区分`null`和`0`、`""`，那么就应该使用比较表达式。

## null和undefined

`null`求值为一个特殊值，通常用于表示某个值不存在，对其使用`typeof`将返回`object`，表明可以将其看作一个特殊对象

`undefined`表示更深层次的不存在，如变量未初始化时、查询不存在的对象属性或数组元素时。它是个预定义的全局变量，对`undefined`调用`typeof`会返回`"undefined"`，表示该值是特殊类型的唯一成员。

没有明确返回值的函数返回`undefined`，未传函数参数值的值也是`undefined`。

`==`认为它们相等，但是`===`认为它们不相等。

## 符号

符号(Symbol)是ES6新增的一种原始类型，用于非字符串的属性名。

先要了解JS的基础类型Object是一个属性的无序集合，其中每个属性都有一个名字和一个值。属性名通常是字符串，但在ES6后，符号也可以作为属性名：

```js
let strname = "string name";			// 可用作属性名的字符串
let symname = Symbool("propname");		// 可用作属性名的符号

typeof strname					// string strname是字符串
typeof symname					// symbol symname是符号

let o = {};						// 创建一个新对象
o[strname] = 1;					// 使用字符串名定义一个属性
o[symname] = 2;					// 使用符号名定义一个属性
o[strname]						// 1 访问字符串名字的属性
o[symname]						// 2 访问符号名字的属性
```

要获取`Symbol`值，必须要调用`Symbol()`函数。该函数永远不会返回相同的值，即使每次传入的参数都相同。

实际中，符号通常用作一种语言扩展机制。

`Symbol()`可以接受一个字符串参数，返回唯一的符号值。若提供了字符串参数，那么调用返回符号值的`toString()`方法得到的结果中会包含该字符串。

jS定义了一个全局符号注册表。`Symbol.for()`函数接受一个字符串参数，返回一个与该字符串关联的符号值。如果没有关联的，就会创建并返回一个新符号；否则，就会返回已有的符号。

`Symbol()`和`Symbol.for()`完全不同：

- `Symbol()`：永远不会返回相同值
- `Symbol.for()`：以相同的字符串调用时，始终返回相同的值。可以通过`Symbol.keyFor(标识符)`得到字符串。

## 全局对象

全局对象的属性是全局性定义的标识符，可以在JS程序的任何地方使用。

JS解释器启动后，都会创建一个新的全局对象并为其添加一组初始的属性，定义了：

- `undefined`、`Infinity`、`NaN`这样的全局常量
- `isNan()`、`parseInt()`、`eval()`这样的全局函数
- `Date()`、`RegExp()`、`String()`这样的构造函数
- `Math()`、`JSON()`这样的全局对象

它们不是保留字，但是应该被当成保留字。

ES2020最终定义了`globalThis`作为任何上下文中引用全局对象的标准方式。2020年初，所有现代浏览器和Node都实现了该特性。

## 不可修改的原始值与可修改的对象引用

对象不是按值比较的，两个对象即使拥有相同的属性和值，它们也不相等。

对象有时被称为引用类型(reference type)，以区别Javascript的原始类型。

可以说，两个对象值只有在它们引用同一个底层对象的时候，才是相等的。

## 类型转换

| 值             | 转换为字符串     | 转换为数值 | 转换为布尔值 |
| -------------- | ---------------- | ---------- | ------------ |
| `undefined`    | `"undefined"`    | `NaN`      | `false`      |
| `null`         | `"null"`         | `0`        | `false`      |
| `true`         | `"true"`         | `1`        |              |
| `false`        | `"false"`        | `0`        |              |
| `""`           |                  | `0`        | `false`      |
| `"1.2"`        |                  | `1.2`      | `true`       |
| `"one"`        |                  | `NaN`      | `true`       |
| `0`            | `"0"`            |            | `false`      |
| `-0`           | `"0"`            |            | `false`      |
| `1`            | `"1"`            |            | `true`       |
| `Infinity`     | `"Infinity"`     |            | `true`       |
| `-Infinity`    | `"-Infinity"`    |            | `true`       |
| `NaN`          | `"NaN"`          |            | `false`      |
| `{}(任何对象)` | 后面会说         | 后面会说   | `true`       |
| `[空数组]`     | `""`             | `0`        | `true`       |
| `[9]`          | `"9"`            | `9`        | `true`       |
| `['a']`        | 使用`join()`方法 | `NaN`      | `true`       |
| `function(){}` | 后面会说         | `NaN`      | `true`       |

### 转换与相等

全等：`===`

值等：`==`

`if`会把`undefined`转成`false`，但`==`不会把其操作数转为布尔值。

### 显式转换

- `Boolean()`
- `Number()`
- `String()`

除`null`和`undefined`之外的所有值都有`toString()`方法，该方法返回的结果通常与`String()`函数返回的结果相同。

有些JS操作符会执行隐式类型转换：

- `+`操作符只要有个运算对象是字符串，就会把另一个也转成字符串。
- 一元操作符`+`会将操作数转为数值
- 一元操作符`!`会将操作数转为布尔值，再取反

`Number`类定义的`toString()`有个可选参数，用于指定一个基数或底数。默认是`10`，可选`2`到`36`：

```js
let n = 17;
let binary = "0b" + n.toString(2);			// binary == "0b10001"
let octal = "0o" + n.toString(8);			// octal == "0o21"
let hex = "0x" + n.toString(16);			// hex == "0x11"
```

### 对象到原始值转换

JS规定对象到原始值转换的三种基本算法：

- 偏字符串
- 偏数值
- 无偏好

#### 对象转布尔值

所有对象都转为`true`。

#### 对象转字符串

将对象转字符串时，JS先用偏字符串算法将其转为一个原始值，再将得到的原始值转为字符串。

#### 对象转数值

需要把对象转数值时，JS先用偏数值算法将其转为一个原始值，然后再将得到的原始值转为数值。

#### 操作符转换特例

`+`执行：

1. 数值加法
2. 字符串拼接
3. 其它情况使用无偏好算法将对象转为原始值

`==`和`!=`执行：若一个操作数是对象，一个是原始值，则会使用无偏好算法将对象转为原始值再比较。

关系运算符执行：操作数有一个是对象就会使用偏数值算法将对象转为原始值。

两个`Date`对象进行关系运算，会先被无偏好算法转为字符串。

#### toString()和valueOf()方法

`toString()`返回对象的字符串表示。

```cpp
({x: 1, y: 2}).toString()		// "[object Object]"
```

很多类都定义了自己的`toString()`版本。例如`Array`类的`toString()`会把数组里的每个元素转为字符串，再用逗号作为分隔符将它们拼接起来。

`valueOf()`可以认为它是将对象转为代表对象的原始值。因为对象是复合值并且大多对象不能真正通过一个原始值来表示，所以`valueOf()`方法默认只返回对象本身，而非原始值。

#### 对象到原始值转换算法

- 偏字符串算法先尝试`toString()`方法。若该方法有定义且返回原始值，则JS使用该原始值(即使该值不是字符串)。如果`toString()`不存在，或存在但返回对象，则JS尝试`valueOf()`方法。如果该方法存在且返回原始值，则JS使用该值。否则转换失败，报`TypeError`
- 偏数值算法类似偏字符串算法，但先尝试`valueOf()`，再尝试`toString()`方法。
- 无偏好算法依赖被转换对象的类。若这是个`Date`对象，则JS使用偏字符串算法。若是其他类型的对象，则JS使用偏数值算法。

## 变量声明与赋值

ES6：

- 往前：使用`var`
- 往后：使用`let`和`const`

### 使用let和const声明

```js
// 变量
let i;			// i值为undefined
let sum;
let i, sum;
let message = "hello";		// 好习惯

// 常量
const H0 = 74;				// 哈勃常数(km/s/Mpc)
```

重新给常量赋值会抛出`TypeERror`

常量一般约定用大写表示。

使用`const`的情况：

- 值基本不会改变的情况，如物理常数、程序版本号，标识文件类型的字节序。
- 程序中有很多所谓的变量实际上在程序运行时并不会改变。

#### 常量与常量作用域

用`let`和`const`声明的变量具有块作用域。

在所有代码块外部的称为全局变量或常量，具有全局作用域。

#### 重复声明

同一作用域中使用多个`let`和`const`声明同一名字是语法错误。

#### 声明与类型

JS里给一个变量赋数值后再赋字符串是合法的。

### 使用var的变量声明

- 不具有块作用域
- 所有函数体外的`var`可以理解为会声明为一个全局变量(但是不能调用`delete`)，与`let`的全局变量不同的是，`var`声明的全局变量被实现为全局对象的属性。全局对象可以通过`globalThis`引用。例如`var x = 2;`，也就相当于`globalThis.x = 2`。
- 使用`var`多次声明同名变量是合法的。
- 在使用`var`声明变量时，该声明会被提升到包含函数的顶部。

### 解构赋值

ES5实现了一种复合声明与赋值语法，称为解构赋值(destructuring assignment)。

```js
let [x, y] = [1, 2];		// x = 1, y = 2
[x, y] = [x+1, y+1];		// x = 2, y = 2
```

解构赋值左右两边的数量不一定相同：

- 左侧多余变量会被设为`undefined`
- 右侧多余的值会被忽略

左侧变量列表可以有多余的逗号，用于跳过右侧的某些值：

```js
let [x, y] = [1];			// x = 1, y = undefined
[x, y] = [1, 2, 3];			// x = 1, y = 2
[, x, , y] = [1, 2, 3, 4];	// x = 2, y = 4
```

亦可以用于嵌套数组：

```js
let [a, [b, c]] = [1, [2, 2.5], 3];		// a = 1, b = 2 , c = 2.5 
// 3被舍弃
```

右值也能不是数组：

```js
let [one, ...rest] = "Hello";			// 包含... one = "H", rest = "ello"
```

亦可以是：

```js
let transparent = {r: 0.0, g: 0.0, b: 0.0, a: 1.0};		// 一个RGBA颜色对象
let {r, g, b} = transparent;			// r = 0.0, g = 0.0, b = 0.0
```

使用嵌套对象、对象的数组，或数组的对象时，解构赋值会更加赋值，但都是合法的：

```js
let points = [{x: 1, y: 2}, {x: 3, y: 4}];			// 两个坐标点对象的数组
let [{x: x1, y: y1}, {x: x2, y: y2}] = points;		// 解构到4个变量中
// x1 = 1, y1 = 2, x2 = 3, y2 = 4
```

若非解构对象的数组，亦可以解构数组的对象：

```js
let points = {p1: [1, 2], p2: [3, 4]};			// 有两个数组属性的对象
let {p1: [x1, y1], p2: [x2, y2]} = points;		// 解构到4个变量中
// x1 = 1, y1 = 2, x2 = 3, y2 = 4
```

