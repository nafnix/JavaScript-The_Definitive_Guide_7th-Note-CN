# 表达式与操作符

## 主表达式

主表达式(primary expression)，即独立存在，不再包含更简单表达式的表达式。

如常量和字面量值、某些语言关键字和变量引用。

## 对象和数组初始化程序

对象和数组初始化程序也是表达式，其值为新创建的对象或数组。

但它们不是主表达式，因为它们包含用于指定属性或元素值的子表达式。

```js
[]			// 空数组
[1+2, 3+4]	// 两个元素的数组
let matrix = [[1,2,3], [4,5,6]];
```

数组字面量中省略逗号间的值可以包含未定义元素。

```js
let sparese Array = [1,,,,5];
```

如果后面再跟个逗号，那么后面不会创建：

```js
let sparese Array = [1,,,,5,];		// 长度还是5
```

如果访问超出数组的长度的元素会返回`undefined`。

ES6之后，对象字面量可以嵌套：

```js
let rectangle = {
    upperLeft: {x: 2, y: 2},
    lowerRight: {x: 4, y: 5}
};
```

## 函数定义表达式

```js
// 该函数返回传入值的平方
let square = function(x) { return x * x};
```

## 属性访问表达式

```js
// 第一种
表达式.标识符

// 第二种
表达式[表达式]
```

示例：

```js
let o = {x: 1, y: {z: 3}};
let a = [o, 4, [5, 6]];
o.x;				// 1
o.y.z;				// 3
o["x"];				// 1
a[1];				// 4
a[2]["1"]			// a[2]中索引为1的元素
a[0].x				// 1
```

先求`.`或`[`前的表达式的值，如果结果为`null`或`undefined`就抛出`TypeError`。

### 条件是属性访问

ES2020新增：

```js
// 第一种
表达式?.标识符

// 第二种
表达式?.[表达式]
```

用于防止`.`和`[]`访问返回的错误。用法与属性访问表达式相同，只是前面加了个`?`。

## 调用表达式

```js
函数表达式(参数)
对象.函数表达式(参数)
```

### 条件式调用

ES2020后可以用`?.()`来调用。

```js
log?.(x);			// 如果有log函数就调用

o.m()				// 常规属性访问 常规调用
o?.m()				// 条件式属性访问 常规调用
o.m?.()				// 常规属性访问 条件是调用
```

## 对象创建表达式

对象创建表达式创建一个新对象并且调用构造函数来初始化该新对象。

```js
new 对象();
```

如果不会给构造函数传参数，可以省略括号：

```js
new 对象;
```

## 操作符概述

降序：

1. `++`
2. `--`
3. `-`
4. `+`
5. `~`
6. `!`
7. `delete`
8. `typeof`
9. `void`
10. `**`
11. `*`、`/`、`%`
12. `+`、`-`
13. `+`
14. `<<`
15. `>>`
16. `>>>`
17. `<`、`<=`、`>`、`>=`：按数值顺序比较
18. `<`、`<=`、`>`、`>=`：按字母表顺序比较
19. `instanceof`：测试对象类
20. `in`：测试属性是否存在
21. `==`
22. `!=`
23. `===`
24. `!==`
25. `&`
26. `^`
27. `|`
28. `&&`
29. `||`
30. `??`
31. `?:`
32. `=`
33. `**=`、`*=`、`/=`、`%=`、`+=`、`-=`、`&=`、`^=`、`|=`、`<<=`、`>>=`、`>>>=`
34. `,`

### 操作数个数

大多都是二元操作符。

### 操作数与结果类型

有些操作符适用于任何类型的值，但大多操作符期待自己的操作数是某种特定类型，且大多操作符也是返回特定类型的值。

### 操作符副效应

有些表达式是有副效应的，对他们求值可能影响将来求值的结果。

例如赋值操作符：将一个值赋给变量或属性，会改变后续使用该变量或属性的表达式的值。

### 操作符优先级

属性访问和调用表达式的优先级高于上述符号中的所有操作符。

```js
// my是个有functions属性的对象 
// functions属性是个函数的数组
// 这里调用了x号函数 并传给它参数的y 
// 然后再求值(typeof)函数调用返回值的类型
typeof my.functions[x](y)
```

ES2020要求在混用`??`和`||`和`&&`时必须用圆括号。

### 操作符结合性

左结合律示例：

```js
w = x - y - z;
// 等价于
w = ((x - y) - z);
```

右结合律示例：

```js
y = a ** b ** c;
y = (a ** (b ** c));

x = ~-y;
x = ~(-y);

w = x = y = z;
w = (x = (y = z));

q = a?b:c?d:e?f:g;
q = a?b:(c?d:(e?f:g));
```

### 求值顺序

JS始终严格按照从左到右的顺序对表达式求值。

```cpp
w = x + y * z;
// 求w
// 求x y z
// 求y * z = temp
// 求x + temp
```

只有在一种情况下会造成差异，也就是被求值的表达式具有副效应，这会影响其他表达式的求值。例如表达式`x`要递增一个变量，但是表达式`y`会用这个变量，这时候要保证`x`先于`y`被求值就很重要了。

## 算术表达式

无法转换数值的非数值操作数会被转为`NaN`。只要有个操作数是`NaN`，结果就是`NaN`。

### +操作符

```js
1 + 2					// 3
"hello" + " " + "there"	// "hello there"
"1" + "2"				// "12"
```

行为：

- 有一个操作数是对象：
  - `Date`对象用`toString()`转换
  - 其它对象用`valueOf()`转换
  - 多数对象没有`valueOf()`方法，所以它们也是通过`toString()`方法转换
- 完成对象到原始值的转换后，若有操作数是字符串，则另一个操作数也会被转为字符串并拼接
- 否则两个操作数都被转为数值`NaN`，计算加法

例子：

```js
1 + 2			// 3
"1" + "2"		// "12"
"1" + 2			// "12"
1 + {}			// "1[object Object]"
true + true		// 2 布尔值转为字符串后计算加法
2 + null		// 2 null转为0计算加法
2 + undefined	// NaN undefined转为NaN后计算加法

1 + 2 + " blind mice"			// "3 blind mice" 
1 + (2 + " blind mice")			// "12 blind mice"
```

### 一元算术操作符

- 一元加`+`：将其操作数转为数值或`NaN`后返回，如果操作数是数值，则什么也不做。
- 一元减`-`：同一元加，但之后会改变结果的符号。
- 递增`++`：同一元加，但之后会将其操作数加`1`，操作数必须是左值。不会执行字符串拼接。
- 递减`--`：类似递增，不过是减`1`。

### 位操作符

位操作符期待整数操作数，且将它们当成32位整数而非64位浮点数。

必要时会把操作数转为数值，然后再将得到的数值强制转为32位。也就是丢弃小数部分和32位以外的部分。

`NaN`、`Infinity`、`-Infinity`在作为这些位操作符的操作数时都会转为`0`。

除了`>>>`之外所有的位操作符都可以用于常规数据或`BigInt`操作数。

- 按位与`&`：对其整数参数的每一位进行布尔与操作。对应位都是`1`，结果位为`1`。
- 按位或`|`：对其整数参数的每一位进行布尔或操作。对应位只要有个是`1`，则结果位为`1`。
- 按位异或`^`：对其整数参数的每一位进行布尔异或操作。对应位只有一个是`1`时，则结果位为`1`，否则`0`。
- 按位非`~`：一元操作符，出现在操作数前。反转操作数中所有位。
- 左移`<<`：将左侧操作数按照右侧数值移动指定的位数。`a<<1`，`a`的第`1`位移动至第`2`位，`2`移`3`......新的第`1`位被填充`0`
- 有符号右移`>>`：类似左移，不过移动方向相反，填充到左边的位取决于原始操作数的符号，若左侧操作数为正数，则填充`0`，若为负数，则填充`1`。
- 零填充右移`>>>`：类似有符号右移，不过填充的是`0`。若湘江有符号32位值看作无符号整数(正数)，可以用这个。

## 关系表达式

返回`true`或者`false`。

### 相等和不相等操作符

相等：

- `==`：测试相等，判断操作数是否相同。早期JS特性，被认为是个隐患，实践中应该用`===`。
- `===`：严格相等，检查是否完全相同。

不相等：

- `!=`：不相等
- `!==`：不严格相等

#### 严格相等

- 类型不同，则不等
- 都是`null`或`undefined`则相等
- 都是`true`或都是`false`则相等
- 有一个是`NaN`就不相等(`NaN`不等于它自己)
- 都是数值且值相等，则相等。
- 都是字符串且相同位置包含完全相同的16位值则相等。(可能有两个字符看起来相同，但是底层编码却是不同的16位值序列)
- 若两个值引用同一个对象、数组或函数，则它们相等。如果它们引用不同的对象，即使两个对象有完全相同的属性，也不相等。

#### 基于类型转换的相等

对于`==`，若两个操作数类型不同，它会尝试做类型转换后再比较。

- 类型相同，则使用严格相等判断。
- 类型不同，则：
  - 有个是`null`，另一个是`undefined`，则相等。
  - 有个是数值，一个是字符串，则把字符串转为数值，再比较转换后的结果是否相等。
  - 如果有个是`true`，则转为`1`，有个是`false`，则转`0`再比较。
  - 如果有个是对象，另一个是数值或字符串，则尝试对象到原始值的转换后再作比较。
  - 其它任何值的组合都不想等。

```js
"1" == true			// 结果为真
```

### 比较操作符

`<`、`<=`、`>`、`>=`

规则：

- 若有操作数求值为对象，则尝试对象到原始值的转换后比较。
- 若在完成对象到原始值的转换后两个操作数都是字符串，则使用字母表顺序比较。
- 若在完成对象到原始值的转换后有一个操作数不是字符串，则都转成数值并按照数值顺序进行比较。

JS字符串是16位整数值的序列，字符串比较就是比较两个字符串的==数值==序列。

### in操作符

左边是字符串、符号或能够转为字符串的值，右边是对象。

如果左边的值是右边的对象的属性名，则`in`返回`true`。

```json
let point = {x: 1, y: 1};			// 定义对象
"x" in point						// true 对象有名为"x"的属性
"z" in point						// false 对象没有名为"z"的属性
"toString" in point					// true 对象继承了toString的方法

let data = [7, 8, 9];				// 数组 有元素(索引)0、1、2
"0" in data							// true 数组有元素"0"
1 in data							// true 数值会转为字符串
3 in data							// false 没有元素3
```

### instanceof操作符

左边是对象，右边是对象类的标识。

若左边是右边的实例时返回`true`，否则`false`。

JS里，对象类是通过初始化它们的构造函数定义的。所以`instanceof`右边应该是个函数：

```js
let d = new Date();			// 通过Date()构造函数创建一个对象
d instanceof Date;			// true d是通过Date创建的
d instanceof Object			// true 所有对象都是Object的实例
d instanceof Number			// false d不是Number对象

let a = [1, 2, 3];			// 通过数组字面量创建一个数组
a instanceof Array;			// true
a instanceof Object;		// true
a instanceof RegExp			// false
```

所有对象都是`Object`的实例。

左边不是对象时，返回`false`。

右边不是对象的类时，抛出`TypeError`。

`instanceof`的工作原理有关"原型链"。第六章会详细介绍原型链。

为对`o instanceof f`求值：

1. JS会求值`f.prototype`
2. 然后在`o`的原型链上找这个值：
   - 找到了，则`o`为`f`的实例，`instanceof`返回`true`。
   - 不然就表明`f.prototype`不是`o`原型链上的一个值，即`o`不是`f`的实例，`instanceof`返回`false`。

## 逻辑表达式

### 逻辑与&&

左右都是`true`时返回`true`，不然`false`。

关系操作符优先级高于`&&`和`||`

先算左边，左边如果是真才会执行右边，所以其实可以：

```js
if (a === b) 
    stop();

(a === b) && stop(); // 效果与上面一样
```

### 逻辑或||

类似逻辑与，不过是只要有一个是真就返回`true`，不然`false`。

常用于在一系列备选项中选择第一个真值：

```js
// 如果maxWidth是真值 就用它 
// 否则就查看preferences对象
// 如果也没有就用硬编码的常量
let max = maxWidth || preferences.maxWidth || 500
```

ES6前，该惯用法常用于在函数中给参数提供默认值：

```js
// 复制o的属性给p 返回p
function copy(o, p) {
    p = p || {};		// 若没有传入对象p 使用新创建的对象
    // 这里是函数体
}
```

ES6后可以直接把默认参数卸载函数定义中：

```js
function copy(o, p={}) {
    // ...
}
```

### 逻辑非!

用于反转其操作数的布尔值。

会先将操作数转为布尔值，再将布尔值反转。

`!`优先级较高，若想反转表达式`p && q`的值，需要用圆括号：`(!p && q)`。

## 赋值表达式

### 通过操作赋值

```js
total += salesTax;
total = total + salesTax;
```

- `+=`
- `-=`
- `*=`
- `/=`
- `%=`
- `**=`
- `<<=`
- `>>=`
- `>>>=`
- `&=`
- `|=`
- `^=`

## 求值表达式

```js
eval("3+2")		// 5
```

`eval()`是函数。

### eval()

`eval()`的参数：

- 非字符串：返回该值
- 字符串：当作JS代码解析，解析失败则抛出`SyntaxError`。若字符串的运行结果没返回值，则返回`undefined`。

### 全局eval()

一般现代的JS解释器会执行大量的代码分析和优化。

而`eval()`会干扰JS的优化程序。这是因为它会修改局部变量。

解释器不会过多优化调用`eval()`的函数。

若`eval()`被以`"eval"`之外的其它名字调用时，它应该把字符串当成顶级全局代码来求值。被求值的代码可能定义新全局变量或全局函数，可能修改全局变量，但是不会再使用或修改调用函数的局部变量。所以也就不会妨碍局部优化。

直接使用`"eval"`调用`eval()`函数称为"直接`eval`"。直接调用`eval()`使用的是调用上下文的变量环境。

此外其它方式调用包括间接调用，都是使用全局对象作为变量环境，所以不能读写或定义局部变量或函数。

```js
const global_eval = eval;			// 别名
let x = "global", y = "global";		// 两个全局变量

function f() {					// 这个函数直接调用eval()
    let x = "local";			// 定义一个局部变量
    eval("x += 'changed';");	// 直接调用修改局部变量
    return x;					// 返回修改后的值
}

function g() {
    let y = "local";				// 局部变量
    global_eval("y += 'changed';");	// 间接调用修改全局变量
    return y;						// 返回未修改的局部变量
}
console.log(f(), x);			// 修改了局部变量 "localchanged global"
console.log(g(), y);			// 修改了全局变量 "local globalchanged"
```

### 严格eval()

严格模式对`eval()`函数增加了更多限制，甚至对标识符`"eval"`的使用也进行了限制。

在该模式下调用`eval()`时，或者当被求值的代码字符串以`"use strict"`指令开头时，`eval()`会基于一个私有变量环境进行局部求值。

也就是被求值的代码可以查询以及设置局部变量，但是不能在局部作用域里定义新的变量或者函数。

严格模式下，`eval()`变得更像操作符，因为在严格模式下，`"eval"`会变成保留字。

想要声明或重写`eval`都是不允许的。

## 其它操作符

### 条件操作符?:

三元操作符

```js
判断 ? 为真执行 : 为假执行;
```

### 先定义??

先定义(first-defined)，若左边不是`null`或`undefined`就返回左边的操作数，否则返回右边的操作数。

类似`&&`和`||`，它是短路的。

可以理解为：

```js
(a !== null && a != undefined) ? a : b;
```

同时这也是对`||`都一个有用的替代：

```js
let max = maxWidth || preferences.maxWidth || 500;		// 如果前两个操作数都是0那就不会选择它们
let max = maxWidth ?? preferences.maxWidth ?? 500;		// 即使前两个操作数是0也会选择它们
```

于ES2020定义。正式名称为"缺值合并"(nullish coalescing)操作符，但我没有使用这个叫法。

### typeof操作符

JS值在应用`typeof`操作符后得到的值：

| x               | typeof x      |
| --------------- | ------------- |
| `undefined`     | `"undefined"` |
| `null`          | `"object"`    |
| `true`或`false` | `"boolean"`   |
| 任意数值或`NaN` | `"number"`    |
| 任意`BigInt`    | `"bigint"`    |
| 任意字符串      | `"string"`    |
| 任意符号        | `"symbol"`    |
| 任意函数        | `"function"`  |
| 任意非函数对象  | `"object"`    |

用例：

```js
(typeof value === "string") ? "'" + value + "'" : value.toString()
```

若操作数的值是`null`，`typeof`返回`object`。若想区分`null`和对象，必须显式测试这个特殊值。

### delete操作符

尝试删除其操作数指定的对象属性或数组元素。

```js
let o = {x: 1, y: 2};
delete o.x;		// 删除该属性
"x" in o		// false

let a = [1,2,3]
delete a[2]
2 in a			// false
a.length		// 3 数组长度没有变化
```

被删除的属性或数组元素会被设为`undefined`值。

如果操作数不是左值，那么`delete`什么也不做，且返回`true`。

删除左值，成功为`true`，否则`false`。

严格模式下：

- 操作数是未限定标识符，如变量、函数或函数参数，就会导致`SyntaxError`。
- 删除不可删除属性时，抛出`TypeError`

严格模式外上述两种情况都不会发生，且只是简单返回`false`，表示不能删除。

### await操作数

ES2017新增。

`await`期待`Promise`对象(表示异步对象)作为其唯一操作数，可以让代码看起来像是在等待异步计算完成。`await`操作符的值是`Promise`对象额兑现值。

### void操作符

求自己的操作数，然后丢弃该值并返回`undefined`

### 逗号操作符,

求值左操作数，然后求值右操作数，然后返回右操作数的值：

```js
i = 0, j = 1, k = 2;
// 等价
i = 0; j = 1; k = 2;
```

常用于有多个循环变量的`for`循环。

